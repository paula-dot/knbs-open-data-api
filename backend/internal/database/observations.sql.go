// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: observations.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createObservation = `-- name: CreateObservation :one
INSERT INTO observations (county_id, indicator_id, year, value, source_document)
VALUES ( $1, $2, $3, $4, $5)
RETURNING id, county_id, indicator_id, year, value, source_document, created_at
`

type CreateObservationParams struct {
	CountyID       int32          `json:"county_id"`
	IndicatorID    pgtype.UUID    `json:"indicator_id"`
	Year           int32          `json:"year"`
	Value          pgtype.Numeric `json:"value"`
	SourceDocument pgtype.Text    `json:"source_document"`
}

func (q *Queries) CreateObservation(ctx context.Context, arg CreateObservationParams) (Observation, error) {
	row := q.db.QueryRow(ctx, createObservation,
		arg.CountyID,
		arg.IndicatorID,
		arg.Year,
		arg.Value,
		arg.SourceDocument,
	)
	var i Observation
	err := row.Scan(
		&i.ID,
		&i.CountyID,
		&i.IndicatorID,
		&i.Year,
		&i.Value,
		&i.SourceDocument,
		&i.CreatedAt,
	)
	return i, err
}

const getDataByCountyAndYear = `-- name: GetDataByCountyAndYear :many
SELECT
    o.value,
    o.year,
    c.name as county_name,
    i.name as indicator_name,
    i.unit
FROM observations o
JOIN counties c ON c.id = o.county_id
JOIN indicators i ON i.id = o.indicator_id
WHERE c.id = $1 AND o.year = $2
`

type GetDataByCountyAndYearParams struct {
	ID   int32 `json:"id"`
	Year int32 `json:"year"`
}

type GetDataByCountyAndYearRow struct {
	Value         pgtype.Numeric `json:"value"`
	Year          int32          `json:"year"`
	CountyName    string         `json:"county_name"`
	IndicatorName string         `json:"indicator_name"`
	Unit          string         `json:"unit"`
}

func (q *Queries) GetDataByCountyAndYear(ctx context.Context, arg GetDataByCountyAndYearParams) ([]GetDataByCountyAndYearRow, error) {
	rows, err := q.db.Query(ctx, getDataByCountyAndYear, arg.ID, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDataByCountyAndYearRow{}
	for rows.Next() {
		var i GetDataByCountyAndYearRow
		if err := rows.Scan(
			&i.Value,
			&i.Year,
			&i.CountyName,
			&i.IndicatorName,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
